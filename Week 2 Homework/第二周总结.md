# 第二周总结
## 学习时间和进度
算法训练营第二周，节奏和策略还是不太对头：某一天补了四道每日一题，第一周的作业题全写完了，课后练习也只剩一两个，然而第二周视频只快速看了知识讲解，实战题目解析又是没有动...立flag明天都刷掉...

树：还是比较熟悉了，题目做起来也还好，但是n叉树的遍历还要再多学习题解；  
堆：概念和原理都很清楚，但是用的少，多来几道题吧；  
哈希表、映射、集合：各种形式的HashTable都还明白，但是完全不会用，多看文档多刷题；  
图：之前学算法课的时候除了定义和邻接表/邻接矩阵之外什么都没记住，大概会比较艰难了，慢慢啃吧...

用Java刷题感觉很好，用上数据结构码起来之后，比之前只看基本语法、写各种比Hello World强不了多少的码，要舒服太多了，各种与C++之间的小区别也不用系统的学或者总结，来几次compile error之后就记得死死的了；对比C++要想清楚传值、传指针、传引用，Java基础类型传值、对象类型传引用，非常清晰，反过来也能让自己形成在C++里面尽量多用传引用的习惯了。

## 训练营笔记
很简短的笔记，知道的就不写了，只写一些关键点和之前不知道的：

## 映射 Map 集合 Set
哈希表/散列表：Map/Set的实现方式之一；工程实践：LRU cache；Redis    
Java中通过重载HashCode来导入自定义Hash Function  
Java中HashMap与HashSet基于HashTable（不常用）
 
HashMap/TreeMap <key, value>映射对的集合  
HashSet/TreeSet 单key无value元素的集合  
二者分别对应python中dict和set  
Map常用接口：map.set(key, value) map.get(key) map.has(key) map.size() map.clear()  
Set常用接口：set.add(value) set.delete(value) set.has(value)   
HashSet是利用HashMap的key存放元素来实现的，value均为dummy值  
HashMap的关键函数：put()和get()  

## 树 Tree
链表是特殊化的树，树是特殊化的图  
对于树的遍历不要怕用递归；树的面试题基本都是递归解法

二叉搜索树 BST  
一定注意定义：左子树的全部节点小于根节点，右子树的全部节点大于根节点，而不只是左儿子和右儿子！  
其中序遍历是升序遍历

插入：先搜索，如果找到的话count加一，否则在返回的位置插入

## 堆 Heap
O(1)时间找到最大值（大顶堆）或最小值（小顶堆）的数据结构  
实现：二叉堆（面试，常用） Fibonacci堆（工业应用，性质更好；基于多叉树）  
ADT要求：find O(1) delete O(logn) insert O(logn) 如二叉堆 O(1) 如Fibonacci堆

二叉堆：通过完全二叉树的形式实现；任意节点的值大于子节点的值  
通过一维数组存储：根节点索引为0，则任意节点i的左孩子为2i+1，右孩子为2i+2，父节点为floor((i-1)/2)  
插入：先将插入元素置于堆（数组）的尾部，然后通过HeapifyUp调整  
删除：堆尾元素与堆顶互换后删除原堆顶，然后通过HeapifyDown调整

## 图 Graph
太多了，之后整理...

## 其他：Java的小细节
很多ADT在Java中只是Interface，具体的Implementation自己按需选择；  
Java不支持运算符重载，比如不能用[]对数组以外的数据结构循下标访问，等等；字符串连接的+其实只是一个语法糖（而且效率不高，除非真的有偶尔连接字符串的需求，尽量少用）；  
Java泛型不能使用基本类型，要使用基本类型对应的封装类型，如Integer、Character等；  
从外部遍历以链表实现的数据结构时最好用iterator或者增强for循环;  
（Java对以链表实现的ADT还保留了循秩访问的接口，虽然能理解这是为了保持ADT接口的一致性，但是也很奇怪为什么要把基于数组/向量和链表的ADT Implementation做在同一个Interface里面...） 

## 其他：对OOP、封装、ADT、实现的反思
1. Java没有指针，不能直接访问内存，而且以链表实现的数据结构里的prev和next对外是不可见的，那么遍历应该就真的只能用iterator了；
2. 但是C++的List的prev和next对外也是不可见的，有某个元素的指针也不能通过prev和next访问，还是只能用iterator;
3. 然后我才意识到自己的误区：数据结构课程中一般会让学生自己实现数据结构，自己去实现一个数据结构的类，写各种prev、next、left、right等等封装内部的码；
4. 然而对于数据结构的使用者来说其实只关心而且只能用ADT提供的接口，比如想要使用Map，那么选择HashMap还是TreeMap也只是出于性能考虑，此后使用起来也并不需要也不能干预内部的HashTable或者Tree的运作方式；
5. 再比如，C++的List作为ADT实际上应该叫列表，只有实现List的数据结构才能真正叫做双向链表，因为List ADT定义的接口中并不具有双向链表的所有功能；iterator的设计也是各种ADT为使用者提供的一项功能，以安全的进行遍历，无论其背后是循秩随机访问还是循地址连续访问，对使用者来说迭代器就是一个透明的遍历工具；
6. 总之，实现ADT时要考虑内部工作原理，选择ADT的实现时考虑一下用途和性能就行了，最终调用ADT接口的时候就与封装内部的操作完全绝缘了。