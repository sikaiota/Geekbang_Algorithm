# 第九周总结
## 学习进度
算法训练营第九周，布隆过滤器在分布式课程学过，LRU缓存在Comuter Architecture课上做了不知道多少遍，但是软件实现与硬件实现感觉还是不太一样的（虽然目的相同），看一下面试题是什么形式；剩下的部分没来得及看完，就先把之前学过的排序算法简单总结一下。

## 训练营笔记
布隆过滤器、LRU缓存、一些之前的排序笔记

## 布隆过滤器 Bloom Filter
与哈希表进行对比：无误差，完全存储  
工业级应用需求：只需要保存元素是否存在，表很小，不存储所有信息  

实现：一个很长的二进制向量和一系列随机映射函数  
作用：检测一个元素是否在一个集合中  
每个元素插入时映射的所有二进制位都置为1  
只要某元素对应的二进制位有一个为0，那这个元素一定不存在  
但某元素对应的二进制位均为1，只能说很有可能存在，可能误报

优点：空间效率和查询时间远超一般的算法  
缺点：有一定的误识别率，删除困难  
一般只作为数据库的快速缓存  
应用：大型分布式系统：搜索引擎，区块链网络，Redis缓存，垃圾邮件/信息的过滤  

## LRU缓存
两个要素：大小、替换策略  
O(1)查询、修改、更新  
软件实现：哈希表+双向链表  
除LRU之外还有其他的替换策略，如LFU（按使用频率）  
*很像现在的推荐算法！

## 一些排序算法的旧笔记
### 起泡排序 bubble sort
起泡排序：最优情况O(n) 平均O(n^2)  
起泡排序的优化：检测已经有序的后缀，缩小范围；检测已经有序的前缀，提前结束  
起泡排序具有稳定性：重复元素的相对顺序保持不变  
稳定性的重要性：  
*基数排序 radix sort 适用于被排序元素可分为若干个域的情况，它的正确性要依赖于对每个域分别排序时的稳定性  
（先排序的域在后排序的域看来是不透明的，所以后排序的域必须保持稳定性）  
### 适用于链表的排序算法
选择排序 selection sort 起泡排序利用List移动操作O(1)特性的优化版  
通过remove-insert来移动最大节点，因为调用new/delete导致代价过高；可以交换指针或者数据的引用  
时间复杂度与起泡排序一致，但大多是比较操作，而非更费时的移动/交换操作  

插入排序 insertion sort 只适于List  
仅使用O(1)的空间（就地算法 in-place algorithm）且输入敏感（input-sensitive）  
时间复杂度取决于逆序对总数I：O(I+n)  
I+n为总比较次数 完全逆序时I取最大值->最坏情况 反之I=0->最好情况

选择排序：O(n^2) 插入排序：O(n)-O(n^2)
### 归并排序 merge sort
分治的思想：前后两段分别递归mergeSort，两段有序后merge  
时间复杂度：O(nlogn)