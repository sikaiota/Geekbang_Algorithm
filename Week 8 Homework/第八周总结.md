# 第八周总结
## 学习进度
算法训练营第八周，还是没有花足够时间来学习，主要看了字典树和并查集部分，位运算之前做的还行，刷题也还好，AVL和红黑树也学过，之后复习。
 
字典树的实现方式居然猜到了是一个一个字符向下深入，每个结点用数组存储也很合理，毕竟只要限定字符长度或者范围，那么每个字符取值的数量就是固定的，无论是26个字母还是一个字节0-255的取值，感觉是非常规整的多叉树，不过的确空间占用非常大；  
并查集之前学的时候感觉实现方式也容易理解，就是缺乏直观的感受，不知道有什么合适的应用场景，学一次忘一次，还是得用五毒神掌多过几遍，不断提醒自己这就是个数组。

## 训练营笔记
字典树和并查集的小总结

## 字典树 Trie
又称单词查找树、键树，属于多叉树  
必要性：用BST不好处理的前缀/字符串匹配问题  
典型应用：统计和排序大量的字符串（不限于字符串）  
场景：搜索引擎系统：文本词频统计，根据输入智能推荐搜索词  
其他应用：拼写检查，IP路由（最长前缀匹配），T9打字预测，单词游戏  
核心思想：空间换时间，利用字符串的公共前缀降低查询开销来提高效率  
优点：最大限度地减少无谓的字符串比较，查找效率比哈希表高  

数据结构特点：  
1. Trie中结点本身不存完整单词  
2. 从根结点到某一结点上的路径上经过的字符连接起来，为该结点对应的字符串  
3. 每个结点的所有子结点路径代表的字符都不相同  

叶子结点最后指向null表示结束  
结点可以存储额外信息，如频次  

参考实现：  
结点用数组存储（一旦分配空间不可更改长度），下标与字符固定映射，值为子节点的指针；  
或者每个结点都是一个dict，key为下一个字符，value为对应的子节点（python中的确方便，但是开销是不是比数组大太多了？）

## 并查集 Disjoint Set
并查集的题目变化不多，记住模板套用就行  
适用场景：组团、配对问题；关联需要有传递性  
基本操作：makeSet(s) unionSet(x, y) find(x)  

实现：动态分配长度为count的数组（元素总数不会变），初始化时每个元素的值等于其下标  
下标为元素本身，值为parent的值  
初始化：单元素集合，元素的parent指向自己  
合并：一个集合的头部元素的parent指向另一个集合的头部元素  
调用find的时候进行路径压缩，即沿查找路径的所有元素的parent都直接指向头部元素  
（引入rank之后可以做到近似常数时间）

## 一些例题
朋友圈：可以用类似于岛屿问题的DFS/BFS解法；正解要用并查集：建立并查集-合并-返回集合个数，其中集合数量需要追踪，在合并的时候集合数量减1（用set的方式感觉开销较大，不如实时更新集合数量）  
位1的个数和颠倒二进制位：都是用按位与的方式进行分治，达到近似常数时间的log log的效率