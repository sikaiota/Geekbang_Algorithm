# 第四周总结
## 学习进度
算法训练营第四周，除了DFS/BFS的四道作业题还没做，外加零散的四五道题，其余大部分前四周的本周作业+课后练习做完了（还剩零散的四五道），分成Homework/Extra传到GitHub上，算是鼓励一下自己吧；
 
补刷第三周的题，最大的感受是终于开始理解回溯是怎么一回事了；数学函数题的边界条件是真的很讨厌，不过有些小技巧记住就行了；还有些题在test case数据规模未知的情况下，是不是值得用overhead很大的数据结构，会感觉很难拿捏，没啥办法，还是经验问题吧。

## 训练营笔记
补刷第三周时对回溯的一些想法，DFS/BFS，贪心，二分，避免int溢出的小技巧，其他

## 关于回溯的思考
*回溯的“回头看”特性：递归分叉时，保留原结果（以副本调用下次递归），或递归调用返回后做清理，取决于生成副本的开销

*依稀有这样的联想：递归-栈-回溯-DFS？迭代-队列-DP-BFS？

*回溯类题目多用DFS，因为DFS的返回成本低，递归由系统栈维护，而BFS需要自行维护队列、实现节点类并储存大量的利用率较低的状态信息（来自高票解答的总结）

*有些题目递归迭代皆可，迭代不会比递归明显复杂很多，这种题迭代解法也要多看看；电话号码和子集这两个题都用进制或类似进制的做法进行枚举的，避开了回溯，之后要练习回溯写法

## DFS与BFS
搜索/遍历的顺序：深度优先/广度优先/优先级优先；优先级定义是要有现实意义的！

树的前序遍历就是DFS，层次遍历就是BFS  
*对于图的通用DFS只需在前序遍历（递归/迭代）的基础上维护一个已访问集合，并在访问节点之前检查是否已访问即可

递归DFS模板：
1. 若当前节点已访问则直接返回  
2. 当前节点加入已访问集合  
3. 处理当前节点  
4. 对当前节点的所有未访问邻居递归调用DFS  
其中1和4会反复确认节点是否已访问，属于确保正确性的冗余操作

非递归DFS：手动维护一个栈  
BFS：更符合人脑思考逻辑；适于处理最短路径/步数问题  
*对于图的通用BFS只需在层次遍历的基础上维护一个已访问集合，并在访问节点之前检查是否已访问即可（或非递归DFS把栈换成队列）  
*在搜索树上选最短路径时最好用BFS！（选DFS面试官可能就会挂人了吧）

## 贪心算法
贪心 vs DP：  
每个子问题选择局部最优，不能回退，期望得到全局最优  
DP会保存之前的结果，根据之前结果决定当前选择，可以回退

贪心：局部最优；回溯：回退；DP：最优+回退  
主要解决最优化问题，如MST、Huffman  
对大多数问题一般不能得到正确答案，然而一旦可以，很可能是最好方法  
由于高效且比较接近最优解，可作为辅助算法或精确度要求不高的问题  
适用贪心算法的场景：问题能分成子问题，子问题的最优解（最优子结构）能推出最终问题的最优解  

例：322. 零钱兑换  
特例：只有当硬币降序排列后每个都是后一个的倍数，才可以使用贪心算法  
*感觉贪心的题要么看起来很弱智（比如买卖股票的最佳时机II直接从找递增区间变成弱智累加），要么看起来很冒险激进，但是能证明正确之后复杂度暴降（比如跳跃游戏和跳跃游戏II直接把DP的O(n^2)降到O(n)）

## 二分查找
前提：单调性；存在上下界；索引访问（对面试官说可以用二分查找之前，要记得说明这三点原因！）

（二分查找的题目磕磕绊绊做完了，但是区间开闭、循环结束条件、比较方向、是否带等号这些还不熟练，感觉不是所有题都能直接套模板，之后还是要多读题解多总结吧）

## 避免int溢出的技巧
实在是不想用long或者long long这种办法，还是更喜欢用点小技巧：  
乘法溢出改除法（例如二分法算平方根，把 mid * mid > x 改成 mid > x / mid 之类）  
加法溢出改减法（例如二分查找算平均数，把 mid = (lo + hi) / 2 改成 mid = lo + (hi - lo) / 2）  
INT_MIN取相反数溢出（例如 pow(x, n) 的 n 取INT_MIN，我的做法是直接递归降次到 -1 之后用 1.0 / x 解决）

## 我是不是在杀鸡用牛刀？
### 874.模拟行走机器人
费了好大劲，障碍物横坐标为Key建一个Map，每个Key对应的Value是相同横坐标的障碍物的纵坐标的ArrayList（还要sort一下），横纵反过来又是第二个Map
 
横向走纵向走分别看对应的Map，行走方向上有没有障碍物，有的话在ArrayList里边二分查找可能最先撞上的那个，再跟目的地坐标比，看路线会不会经过...

写的要吐，跑过了看时间还是非常好的，结果看题解发现，大家全都是走一步看一步，每一步都查Set看下一步有没有障碍物，运行时间一样很好...

（欲哭无泪，难道test case如果是0走到10000然后9999有个障碍物，不会很慢吗...）

### 433.最小基因变化
*致命问题：用了DFS，真的作大死...

题目里基因长度只有8，题解大都是把当前基因变异了去基因库bank里找，感觉这样搜索树分叉太多了，但是这么做也只有 8 * 3 = 24 个要找的序列，还可以直接去Set里O(1)精确搜索...

自己写的还是直接遍历bank找差异为1的，不过遍历过的会交换到数组左侧，没遍历的留在右侧（来自全排列题解的技巧），性能也可以，大概是bank不够大加上搜索树层级不太多，这样遍历不会超时吧...

### 全排列&全排列II
自己写的时候用了HashMap<Integer, Boolean>或者HashMap<Integer, Integer>去追踪每个元素的使用情况+去重，其实用一个boolean[] visited就可以了，不过好像也没有慢很多；

反而是在无重复的全排列里，把使用过的元素交换到数组左侧，没使用的放在右侧，减少遍历次数，这个小技巧提升更大。

### 51.N皇后
想让N皇后的列坐标按照行的顺序输出，还不想额外加信息，硬生生搜到了LinkedHashSet来保证遍历顺序就是加入顺序...简直是闲着没事干...然后row+col和row-col也是用Set存的，运行是真的够慢的...

## 其他
1. Java的Map和Set里一边遍历一边修改一定要小心，一定使用遍历专用的修改/删除接口
2. Java的三目运算符的返回值必须要使用，不能直接当作if-then-else的替代品，而且优先级很诡异，用的时候注意加括号（总之不如C++里边好用，干脆别用了，老老实实if else）

## 附：二分查找无序位置
（这不就是153题吗...作业里也有啊...）  
很尴尬，没看课件自己写 33.搜索旋转排序数组 的时候，用的就是超哥说的暴力法，先二分找切分点，再正常二分查找，反倒是把这个题也一块解决了
```java
class Solution {
    // 简单改了一下153的接口，返回下标而不是数值
    // 这个自己写的不好，看过题解，最简单的方法是判断中点是不是比右侧小
    public int findPivot(int[] nums) {
        int n = nums.length, rotation = 0;
        if (nums[0] > nums[n - 1]) {
            int lo = 0, hi = n;
            while (hi - lo > 1) {
                int mi = (lo + hi) >> 1;
                if (nums[lo] < nums[mi]) {
                    lo = mi;
                } else {
                    hi = mi;
                }
            }
            rotation = hi;
        }
        return rotation;
    }
}
```